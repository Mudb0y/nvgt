// A bit of code initial version of which was generated by claude, which gives a convenient template function for calling angelscript methods, avoiding the SetArgumentDouble etc calls. The function's return value can be captured as well, pass a prepared context to the first argument of angelscript_call.

#include <angelscript.h>
#include <string>
#include <type_traits>

// Template specializations for setting different argument types
template<typename T> void set_argument(asIScriptContext* ctx, int index, T&& value) {
	if constexpr (std::is_same_v<std::decay_t<T>, double>) {
		ctx->SetArgDouble(index, value);
	} else if constexpr (std::is_same_v<std::decay_t<T>, float>) {
		ctx->SetArgFloat(index, value);
	} else if constexpr (std::is_same_v<std::decay_t<T>, int> || std::is_same_v<std::decay_t<T>, unsigned int>) {
		ctx->SetArgDWord(index, static_cast<asDWORD>(value));
	} else if constexpr (std::is_same_v<std::decay_t<T>, bool>) {
		ctx->SetArgByte(index, value ? 1 : 0);
	} else if constexpr (std::is_same_v<std::decay_t<T>, char>) {
		ctx->SetArgByte(index, static_cast<asBYTE>(value));
	} else if constexpr (std::is_same_v<std::decay_t<T>, short>) {
		ctx->SetArgWord(index, static_cast<asWORD>(value));
	} else if constexpr (std::is_same_v<std::decay_t<T>, long long> || std::is_same_v<std::decay_t<T>, unsigned long long>) {
		ctx->SetArgQWord(index, static_cast<asQWORD>(value));
	} else if constexpr (std::is_pointer_v<std::decay_t<T>>) {
		ctx->SetArgAddress(index, const_cast<void*>(static_cast<const void*>(value)));
	} else if constexpr (std::is_class_v<std::decay_t<T>>) {
		// For user-defined types, pass by object reference
		ctx->SetArgObject(index, const_cast<std::decay_t<T>*>(&value));
	} else {
		static_assert(std::is_arithmetic_v<std::decay_t<T>>, "Unsupported argument type for AngelScript function call");
	}
}

// Helper to get return value based on type
template<typename R> R get_return_value(asIScriptContext* ctx) {
	if constexpr (std::is_same_v<R, void>) {
		return;
	} else if constexpr (std::is_same_v<R, double>) {
		return ctx->GetReturnDouble();
	} else if constexpr (std::is_same_v<R, float>) {
		return ctx->GetReturnFloat();
	} else if constexpr (std::is_same_v<R, int>) {
		return static_cast<int>(ctx->GetReturnDWord());
	} else if constexpr (std::is_same_v<R, unsigned int>) {
		return ctx->GetReturnDWord();
	} else if constexpr (std::is_same_v<R, bool>) {
		return ctx->GetReturnByte() != 0;
	} else if constexpr (std::is_same_v<R, char>) {
		return static_cast<char>(ctx->GetReturnByte());
	} else if constexpr (std::is_same_v<R, short>) {
		return static_cast<short>(ctx->GetReturnWord());
	} else if constexpr (std::is_same_v<R, long long>) {
		return static_cast<long long>(ctx->GetReturnQWord());
	} else if constexpr (std::is_pointer_v<R>) {
		return static_cast<R>(ctx->GetReturnAddress());
	} else if constexpr (std::is_same_v<R, std::string>) {
		// For string returns, AngelScript typically returns a pointer to the string object
		std::string* str_ptr = static_cast<std::string*>(ctx->GetReturnObject());
		return str_ptr ? *str_ptr : std::string{};
	} else if constexpr (std::is_class_v<R>) {
		// For user-defined types
		R* obj_ptr = static_cast<R*>(ctx->GetReturnObject());
		if (obj_ptr) {
			return *obj_ptr;
		}
		return R{}; // Default constructed object
	} else {
		static_assert(std::is_arithmetic_v<R>, "Unsupported return type for AngelScript function call");
	}
}

// Main template function for calling AngelScript functions
template<typename R, typename... Args> R angelscript_call(asIScriptContext* ctx, Args&&... args) {
	static_assert(sizeof...(args) <= 32, "Too many arguments (AngelScript typically supports up to 32)");
	
	// Set all arguments using fold expression (C++17 feature, also available in C++20)
	int index = 0;
	((set_argument(ctx, index++, std::forward<Args>(args))), ...);
	
	// Execute the function
	int result = ctx->Execute();
	
	// Handle execution result
	if (result != asEXECUTION_FINISHED) {
		// You might want to throw an exception or handle errors differently
		// For now, we'll just return a default value for non-void returns
		if constexpr (!std::is_same_v<R, void>) {
			return R{};
		} else return;
	}
	
	// Get and return the result
	if constexpr (std::is_same_v<R, void>) {
		return;
	} else {
		return get_return_value<R>(ctx);
	}
}

// Convenience overload that automatically deduces void return type
template<typename... Args> void angelscript_call(asIScriptContext* ctx, Args&&... args) {
	angelscript_call<void>(ctx, std::forward<Args>(args)...);
}
